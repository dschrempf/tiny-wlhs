diff --git a/shell.nix b/shell.nix
index 0b8d54b..e019e3b 100644
--- a/shell.nix
+++ b/shell.nix
@@ -8,6 +8,7 @@ pkgs.mkShell {
     wayland-protocols
     wayland-scanner
     wlroots
+    wlr-protocols
     pixman
     libxkbcommon
     libffi
@@ -38,6 +39,7 @@ pkgs.mkShell {
   ];
   shellHook = ''
     export WAYLAND_PROTOCOLS=${pkgs.wayland-protocols}/share/wayland-protocols
+    export WLR_PROTOCOLS=${pkgs.wlr-protocols}/share/wlr-protocols/
     export WAYLAND_SCANNER=${pkgs.wayland-scanner}/bin/wayland-scanner
     export WLR_RENDERER=pixman
     unset GHC_PACKAGE_PATH
diff --git a/tinywl/Makefile.shared b/tinywl/Makefile.shared
index 89b7185..fbdef8a 100644
--- a/tinywl/Makefile.shared
+++ b/tinywl/Makefile.shared
@@ -11,7 +11,8 @@ CFLAGS += -fPIC -g -ggdb -O1
 # Output file is now a shared library
 OUTPUT = libtinywl.so
 
-DEPS = tinywl.h xdg-shell-protocol.h
+
+DEPS = tinywl.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
@@ -20,6 +21,10 @@ xdg-shell-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
 
+wlr-layer-shell-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+        $(WLR_PROTOCOLS)/unstable/wlr-layer-shell-unstable-v1.xml $@
+
 $(OUTPUT): tinywl.c $(DEPS)
 	$(CC) $(CFLAGS) -shared \
 		-g -Werror -I. \
diff --git a/tinywl/tinywl.c b/tinywl/tinywl.c
index b6cb5e2..6e0f232 100644
--- a/tinywl/tinywl.c
+++ b/tinywl/tinywl.c
@@ -70,6 +70,9 @@ void focus_toplevel(struct tinywl_toplevel *toplevel,
                                    &keyboard->modifiers);
   }
 }
+static void layer_surface_destroy(struct wl_listener *listener, void *data);
+static void layer_surface_map(struct wl_listener *listener, void *data);
+static void layer_surface_unmap(struct wl_listener *listener, void *data);
 
 static void keyboard_handle_modifiers(struct wl_listener *listener,
                                       void *data) {
@@ -798,12 +801,61 @@ void server_destroy(struct tinywl_server *server) {
     free(server);
 }
 
+static void layer_surface_destroy(struct wl_listener *listener, void *data) {
+    struct tinywl_layer_surface *toplevel = wl_container_of(listener, toplevel, destroy);
+    wl_list_remove(&toplevel->map.link);
+    wl_list_remove(&toplevel->unmap.link);
+    wl_list_remove(&toplevel->destroy.link);
+    free(toplevel);
+}
+
+static void layer_surface_map(struct wl_listener *listener, void *data) {
+    struct tinywl_layer_surface *toplevel = wl_container_of(listener, toplevel, map);
+    wlr_log(WLR_DEBUG, "Layer surface mapped");
+}
+
+static void layer_surface_unmap(struct wl_listener *listener, void *data) {
+    struct tinywl_layer_surface *toplevel = wl_container_of(listener, toplevel, unmap);
+}
+
+
+
+static void server_new_layer_surface(struct wl_listener *listener, void *data) {
+    struct tinywl_server *server = wl_container_of(listener, server, new_layer_surface);
+    struct wlr_layer_surface_v1 *layer_surface = data;
+
+    struct tinywl_layer_surface *toplevel = calloc(1, sizeof(*toplevel));
+    toplevel->server = server;
+    toplevel->layer_surface = layer_surface;
+
+    toplevel->scene_tree = wlr_scene_layer_surface_v1_create( &server->scene->tree, layer_surface)->tree;
+
+    toplevel->destroy.notify = layer_surface_destroy;
+    wl_signal_add(&layer_surface->events.destroy, &toplevel->destroy);
+
+    toplevel->map.notify = layer_surface_map;
+    wl_signal_add(&layer_surface->surface->events.map, &toplevel->map);
+
+    toplevel->unmap.notify = layer_surface_unmap;
+    wl_signal_add(&layer_surface->surface->events.unmap, &toplevel->unmap);
+
+    wlr_log(WLR_DEBUG, "New layer surface created");
+}
+
+void initialize_layer_shell(struct tinywl_server *server) {
+    server->layer_shell = wlr_layer_shell_v1_create(server->wl_display, 3);
+    server->new_layer_surface.notify = server_new_layer_surface;
+    wl_signal_add(&server->layer_shell->events.new_surface, &server->new_layer_surface);
+}
+
 bool server_init(struct tinywl_server *server) {
     wlr_log_init(WLR_DEBUG, NULL);
     
     initialize_output_layout(server);
     initialize_scene(server);
+  
     initialize_xdg_shell(server);
+    initialize_layer_shell(server);
     initialize_cursor(server);
     initialize_seat(server);
 
diff --git a/tinywl/tinywl.h b/tinywl/tinywl.h
index 7618410..2f1058e 100644
--- a/tinywl/tinywl.h
+++ b/tinywl/tinywl.h
@@ -12,6 +12,9 @@
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <xkbcommon/xkbcommon.h>
+#include <wlr/types/wlr_layer_shell_v1.h>
+#include "wlr-layer-shell-unstable-v1-protocol.h"
+
 
 typedef void (*keybinding_handler_t)(xkb_keysym_t sym);
 
@@ -74,9 +77,23 @@ struct tinywl_server {
     struct wlr_output_layout *output_layout;
     struct wl_list outputs;
     struct wl_listener new_output;
-  keybinding_handler_t keybinding_handler;
 
+    keybinding_handler_t keybinding_handler;
+    struct wlr_layer_shell_v1 *layer_shell;
+    struct wl_listener new_layer_surface;
+    struct wl_list layer_surfaces;
+    struct wl_listener configure;
+};
 
+struct tinywl_layer_surface {
+    struct wl_list link;
+    struct tinywl_server *server;
+    struct wlr_layer_surface_v1 *layer_surface;
+struct wlr_scene_layer_surface_v1 *scene_tree;
+    
+    struct wl_listener destroy;
+    struct wl_listener map;
+    struct wl_listener unmap;
 };
 
 struct tinywl_output {
